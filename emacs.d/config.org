#+Title: config.org

#+OPTIONS: TOC:nil
#+STARTUP: overview

* Emacs Configuration

This is my personal Emacs configuration. I use the [[https://github.com/railwaycat/homebrew-emacsmacport][Railwaycat Emacs for Mac]] port. It has two main advantages over the Emacs for Mac OSX port for me: 1. it renders colors in my Powerline better, and 2. It lets me use 2 finger swiping to navigate through buffers, which is very handy when I am looking at Emacs while working on something else.

*** Screenshot of my config
[[https://github.com/apierz/dotfiles/blob/master/Screen%20Shot%202016-07-03%20at%201.05.39%20PM.png?raw=true]] 

* Personal Information

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Andy Pierz"
        user-mail-address "andy@andypierz.com")

#+END_SRC
* Packages and Paths

The first thing that gets loaded is =package=, Emacs' package manager. I then add some common repositories for Emacs packages and initialize package.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" .
  "http://stable.melpa.org/packages/"))

  (setq package-enable-at-startup nil)
  (package-initialize)
#+END_SRC

Next I want to set my load paths, it's mostly the standard folders, plus one for my working Dracula Theme Directory.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "snippets" user-emacs-directory))
  (add-to-list 'load-path "~/.emacs.d/plugins")
  (add-to-list 'load-path "~/.emacs.d/plugins/evil-org-mode")
  (add-to-list 'load-path "/usr/local/Cellar/mu/HEAD/bin/mu")
  (add-to-list 'exec-path "/usr/local/bin")
  (add-to-list 'load-path "/Users/Andy/Documents/Programming_Projects/dracula-theme/emacs")
#+END_SRC

=use-package= is a =require= replacement that helps Emacs load faster. Might be a placebo.

#+BEGIN_SRC emacs-lisp
  (require 'use-package)
#+END_SRC

* Essential Settings

These are basic Emacs settings. They include inhibiting the startup screen and menu-bar and various small visual preferences.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t) (menu-bar-mode -1)
  (tool-bar-mode -1)
  (when (boundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
  (show-paren-mode nil)
  (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
  (setq-default left-fringe-width nil)
  (setq-default indent-tabs-mode nil)
  (eval-after-load "vc" '(setq vc-handled-backends nil))
  (setq vc-follow-symlinks t)
  (setq large-file-warning-threshold nil)
  (setq split-width-threshold nil)
  (setq custom-safe-themes t)
  (put 'narrow-to-region 'disabled nil)
  (setq global-visual-line-mode t)
  (setq word-wrap t)
  (setq initial-major-mode 'org-mode)
  (setq initial-scratch-message "")
  (setq-default fill-column 80)
  (setq-default tab-width 2)
  (put 'dired-find-alternate-file 'disabled nil)

#+END_SRC

I prefer for Emacs to store automatic backups in a central location, rather than leaving them strewn about.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/Dropbox/emacs_backups"))
        backup-by-copying      t  ; Don't de-link hard links
        version-control        t  ; Use version numbers on backups
        delete-old-versions    t  ; Automatically delete excess backups:
        kept-new-versions      5 ; how many of the newest versions to keep
        kept-old-versions      5) ; and how many of the old

#+END_SRC

* Utility Functions

Small utility functions, mostly collected from others.

From [[https://github.com/aaronbieber][aaronbieber]]

#+BEGIN_SRC emacs-lisp
  (defun cycle-powerline-separators (&optional reverse)
    "Set Powerline separators in turn.  If REVERSE is not nil, go backwards."
   (interactive)
   (let* ((fn (if reverse 'reverse 'identity))
     (separators (funcall fn '("arrow" "arrow-fade" "slant"
                               "chamfer" "wave" "brace" "roundstub" "zigzag"
                               "butt" "rounded" "contour" "curve")))
     (found nil))
    (while (not found)
      (progn (setq separators (append (cdr separators) (list (car separators))))
      (when (string= (car separators) powerline-default-separator)
        (progn (setq powerline-default-separator (cadr separators))
           (setq found t)
            (redraw-display)))))))


  (defun rename-this-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (unless filename
        (error "Buffer '%s' is not visiting a file!" name))
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (when (file-exists-p filename)
           (rename-file filename new-name 1))
          (rename-buffer new-name)
  (set-visited-file-name new-name)))))

  (defun delete-this-file ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (or (buffer-file-name) (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?"
                               (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name))
  (kill-this-buffer)))


  (require 'htmlfontify)
  (defun fontify-and-browse ()
    "Fontify the current buffer into HTML, write it to a temp file, and open it in a browser."
    (interactive)
    (let* ((fontified-buffer (hfy-fontify-buffer))
           (temp-file-name (make-temp-file "ff" nil ".html")))
      (with-current-buffer fontified-buffer
        (write-region (point-min) (point-max) temp-file-name))
      (browse-url (concat "file://" temp-file-name))))


  (defun show-first-occurrence ()
    "Display the location of the word at point's first occurrence in the buffer."
    (interactive)
    (save-excursion
      (let ((search-word (thing-at-point 'symbol t)))
        (goto-char 1)
        (re-search-forward search-word)
        (message (concat
                  "L" (number-to-string (line-number-at-pos)) ": "
                  (replace-regexp-in-string
                   "[ \t\n]*\\'"
                   ""
                   (thing-at-point 'line t)
                   ))))))

  (defun switch-to-previous-buffer ()
    "Switch to previously open buffer.
  Repeated invocations toggle between the two most recently open buffers."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (defun narrow-and-set-normal ()
    "Narrow to the region and, if in a visual mode, set normal mode."
    (interactive)
    (narrow-to-region (region-beginning) (region-end))
    (if (string= evil-state "visual")
        (progn (evil-normal-state nil)
  (evil-goto-first-line))))

#+END_SRC

From [[http://www.github.com/hrs][hrs]]

#+BEGIN_SRC emacs-lisp
  (defmacro diminish-minor-mode (filename mode &optional abbrev)
    "Supply a FILENAME, to hide a minor MODE or replace with an ABBREV."
    `(eval-after-load (symbol-name ,filename)
       '(diminish ,mode ,abbrev)))

  (defmacro diminish-major-mode (mode-hook abbrev)
    "Supply a MODE-HOOK, to hide a major MODE or replace with an ABBREV."
    `(add-hook ,mode-hook
               (lambda () (setq mode-name ,abbrev))))
#+END_SRC

Mine + Unknown

#+BEGIN_SRC emacs-lisp

    (defun search-my-notes (searchforthis)
      "Search for SEARCHFORTHIS."
      (interactive "sSearch Query: ")
      (rgrep searchforthis "*.txt"  "~/Dropbox/Notes"))

    (eval-after-load "grep"
      '(grep-compute-defaults))

    (defun minibuffer-keyboard-quit ()
      "Abort recursive edit.
    In Delete Selection mode, if the mark is active, just deactivate it;
    then it takes a second \\[keyboard-quit] to abort the minibuffer."
      (interactive)
      (if (and delete-selection-mode transient-mark-mode mark-active)
          (setq deactivate-mark  t)
        (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
        (abort-recursive-edit)))

    (defun andy-new-empty-buffer ()
      "Open a new empty buffer."
      (interactive)
      (let ((ξbuf (generate-new-buffer "untitled")))
        (switch-to-buffer ξbuf)
        (funcall (and initial-major-mode))
        (setq buffer-offer-save t)))



#+END_SRC

* Visual Stuff

I use my own version of [[https://github.com/dracula/dracula-theme][Dracua Theme]], which includes some extra coloring for Helm, mu4e, some changes to the syntax highlighting and correcting the background color when using Emacs in the terminal. My version is availble at my [[https://github.com/apierz][Github page]]. I also use [[http://sourcefoundry.org/hack/][Hack]] as my font. Right now I'm trying out transparency to see how I like it.

#+BEGIN_SRC emacs-lisp
  (use-package dracula-theme)
  (load-theme 'dracula t)

  (load-theme 'dracula t)
  (set-face-attribute 'default nil
                       :family "Hack" :height 140)

  (set-frame-parameter (selected-frame) 'alpha '(90 90))
  (add-to-list 'default-frame-alist '(alpha 90 90))
#+END_SRC

Just to be double-dog sure it ends up as utf-8...

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq buffer-file-coding-system 'utf-8)
#+END_SRC

I use some diminsh functions I got from [[https://github.com/hrs][hrs]]. This lets me hide some minor modes and rename others as encircled unicode characters. I also rename some major modes to save a little space in my powerline.

#+BEGIN_SRC emacs-lisp
  (diminish-minor-mode 'auto-complete 'auto-complete-mode " ⓐ ")
  (diminish-minor-mode 'flycheck 'flycheck-mode " ⓕ ")
  (diminish-minor-mode 'projectile 'projectile-mode " ⓟ ")
  (diminish-minor-mode 'robe 'robe-mode " ⓡ ")
  (diminish-minor-mode 'flymake 'flymake-mode " ⓜ ")
  (diminish-minor-mode 'evil-snipe 'evil-snipe-local-mode)
  (diminish-minor-mode 'evil-surround 'evil-surround-mode )
  (diminish-minor-mode 'evil-commentary 'evil-commentary-mode)
  (diminish-minor-mode 'yasnippet 'yas-minor-mode)
  (diminish-minor-mode 'autorevert 'auto-revert-mode)
  (diminish-minor-mode 'flyspell 'flyspell-mode)
  (diminish-minor-mode 'undo-tree 'undo-tree-mode)
  (diminish-minor-mode 'evil-org 'evil-org-mode)

  (diminish-major-mode 'emacs-lisp-mode-hook ".el")
  (diminish-major-mode 'haskell-mode-hook "?=")
  (diminish-major-mode 'lisp-interaction-mode-hook "?")
  (diminish-major-mode 'python-mode-hook ".py")
  (diminish-major-mode 'ruby-mode-hook ".rb")
  (diminish-major-mode 'sh-mode-hook ".sh")
  (diminish-major-mode 'markdown-mode-hook ".md")

#+END_SRC

* evil-mode

I prefer the Vim keybindings and use them wherever possible in Emacs. I recently made a switch to HJKL from IJKL when I learned the arrow keys on my =Pok3r= keyboard could be reprogrammed to use HJKL everywhere so I'm currently tring to unlearn my old bad habits.

** Main package:

#+BEGIN_SRC emacs-lisp
  (use-package evil)
  (evil-mode t)
#+END_SRC

** Addons, based on Vim plugins

=evil-surround= is based on tpope's plugin and makes it easy to change surrounding syntax luke ", ', (, {, etc. =evil-commentary= is also based on a tpope plugin that makes it easy to comment a line or lines. [g-c-c] will comment a line [g-c-4-k] will comment the next 4 lines, etc. 

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader)
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
  (use-package evil-commentary
    :config
    (evil-commentary-mode))
  (use-package evil-snipe
    :config
    (evil-snipe-mode 1)
    (evil-snipe-override-mode 1))

#+END_SRC

** Controls

   These give me IJKL controls the places that I want them. Also I use 'hh' as a quick shortcut to return to =evil-normal-state=.

#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :config
    (key-chord-mode 1))

  (key-chord-define evil-insert-state-map "hh" 'evil-normal-state)
  (key-chord-define evil-replace-state-map "hh" 'evil-normal-state)
  (key-chord-define evil-visual-state-map "hh" 'evil-normal-state)
  (key-chord-define evil-motion-state-map "hh" 'evil-normal-state)
  (evil-define-key 'normal dired-mode-map "l" 'dired-find-alternate-file)
  (evil-define-key 'normal dired-mode-map "v" 'dired-toggle-marks)
  (evil-define-key 'normal dired-mode-map "m" 'dired-mark)
  (evil-define-key 'normal dired-mode-map "u" 'dired-unmark)
  (evil-define-key 'normal dired-mode-map "U" 'dired-unmark-all-marks)
  (evil-define-key 'normal dired-mode-map "c" 'dired-create-directory)
  (evil-define-key 'normal dired-mode-map "n" 'evil-search-next)
  (evil-define-key 'normal dired-mode-map "N" 'evil-search-previous)
  (evil-define-key 'normal dired-mode-map "q" 'kill-this-buffer)
  (setq evil-shift-width 2)

#+END_SRC

   I made some changes to the normal =evil-org= keybindings because I think these bindings are more intuitive.

#+BEGIN_SRC emacs-lisp
  (use-package evil-org)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-k") 'org-metaup)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-h") 'org-metaleft)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-j") 'org-metadown)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-l") 'org-metaright)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-K") 'org-shiftmetaup)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-H") 'org-shiftmetaleft)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-J") 'org-shiftmetadown)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-L") 'org-shiftmetaright)
  (evil-define-key 'normal evil-org-mode-map (kbd "K") 'org-shiftup)
  (evil-define-key 'normal evil-org-mode-map (kbd "H") 'org-shiftleft)
  (evil-define-key 'normal evil-org-mode-map (kbd "J") 'org-shiftdown)
  (evil-define-key 'normal evil-org-mode-map (kbd "L") 'org-shiftright)
#+END_SRC

** Evil Leader

   =Evil Leader= is a package that let's you do quick shortcuts in =evil-mode=. While in =evil-normal-state= you press and hold your leader key ( for me its ,) and then press another key to trigger a function. It's very handy and great for triggering little utility functions you come accross.

#+BEGIN_SRC emacs-lisp
  (defun andy--config-evil-leader ()
    "Configure evil leader mode."
    (evil-leader/set-leader ",")
    (setq evil-leader/in-all-states 1)
    (evil-leader/set-key
      "k"  'switch-to-previous-buffer
      "m"  'previous-buffer
      "."  'next-buffer
      ":"  'eval-expression
      "b"  'helm-mini
      "d"  'kill-this-buffer
      "e"  'find-file
      "f"  'fontify-and-browse
      "p"  'cycle-powerline-separators
      "b"  'switch-to-buffer
      "l"  'whitespace-mode       ;; Show invisible characters
      "nn" 'narrow-and-set-normal ;; Narrow to region and enter normal mode
      "nw" 'widen
      "o"  'delete-other-windows  ;; C-w o
      "S"  'delete-trailing-whitespace
      "t"  'gtags-reindex
      "T"  'gtags-find-tag
      "w"  'save-buffer
      "x"  'helm-M-x))

  (global-evil-leader-mode)
  (andy--config-evil-leader)

#+END_SRC

** macOS Specific Stuff

   Use the standard OSX keys for cut/copy/paste.

#+BEGIN_SRC emacs-lisp
  (defun pbcopy ()
    "Use OSX' pasteboard for copying."
    (interactive)
    (call-process-region (point) (mark) "pbcopy")
    (setq deactivate-mark t))

  (defun pbpaste ()
    "Use OSX' pasteboard for pasting."
    (interactive)
    (call-process-region (point) (if mark-active (mark) (point)) "pbpaste" t t))

  (defun pbcut ()
    "Use OSX' pasteboard for cutting."
    (interactive)
    (pbcopy)
    (delete-region (region-beginning) (region-end)))

  (global-set-key (kbd "M-c") 'pbcopy)
  (global-set-key (kbd "C-c x") 'pbcut)
  (global-set-key (kbd "M-v") 'pbpaste)


#+END_SRC

   Switch the macOS =Command= button to be Emacs =Meta= key.

#+BEGIN_SRC emacs-lisp

  (defun mac-switch-meta nil
    "Switch meta between Option and Command."
    (interactive)
    (if (eq mac-option-modifier nil)
        (progn
    (setq mac-option-modifier 'meta)
    (setq mac-command-modifier 'hyper)
  )
      (progn
        (setq mac-option-modifier nil)
        (setq mac-command-modifier 'meta))))

#+END_SRC


** Minor evil Configurations

   Stop that terrible cursor move back nonsense!

#+BEGIN_SRC emacs-lisp

(setq evil-move-cursor-back nil)

#+END_SRC

   Set some shortcuts to the function buttons.

#+BEGIN_SRC emacs-lisp
  (global-set-key [f1]  'mu4e)
  (global-set-key [f2] 'andy-new-empty-buffer)

  (global-set-key [f4] 'fci-mode)
  (global-set-key [f5] 'search-my-notes)
  (global-set-key [f6] 'linum-relative-mode)
#+END_SRC

   Robe Mode Commands

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-j") 'robe-jump)
#+END_SRC

   Magit Commands

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)

#+END_SRC

   Use ESC to quit non-evil stuff

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-motion-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key evil-emacs-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape]'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+END_SRC

   Use =evil= controls in =Dired= and other =motion-state= modes.

#+BEGIN_SRC emacs-lisp
  (setq evil-normal-state-modes (append evil-motion-state-modes
    evil-normal-state-modes))
#+END_SRC

* Helm
Helm is useful for searching through Emacs. I prefer Helm for searching through my buffers, kill ring and other things.

#+BEGIN_SRC emacs-lisp
  (use-package helm)
  (use-package helm-config)
  (global-set-key (kbd "C-x b") 'helm-buffers-list)
  (global-set-key (kbd "C-x r b") 'helm-bookmarks)
  (global-set-key (kbd "C-X m") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)

  (setq helm-split-window-in-side-p t)

  (with-eval-after-load
    'helm (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
       (define-key helm-map (kbd "ESC") 'helm-keyboard-quit)
  )
#+END_SRC

* Org-mode

=Org= is Emacs famous markup language with all kinds of useful features. You can even write your Emacs config in =Org=, which is what I have done here.

#+BEGIN_SRC emacs-lisp
  (use-package org)
  (use-package ox)
  (use-package org-grep)
  (use-package org-capture)

#+END_SRC

These are the basic bindings =Org= recommends you use.

#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

I want everything in my notes folder to open in =Org-mode= and for .txt files to open in =Org-mode=. It is very rare I want to edit a plain text file without Org.

#+BEGIN_SRC emacs-lisp
  (setq org-export-coding-system 'utf-8)
  (setq org-agenda-files (list "~/Dropbox/Notes"))
  (setq org-agenda-file-regexp "\\`[^.].*\\.txt\\|[0-9]\\{8\\}\\'")
  (add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
  (setq org-agenda-text-search-extra-files (list nil ))


  (add-hook 'find-file-hooks 
    (lambda ()
      (let ((file (buffer-file-name)))
      (when (and file (equal (file-name-directory file) "~/Dropbox/Notes"))
      (org-mode)))))
#+END_SRC

I prefer to turn line numbers off while in =Org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package linum-off
    :config
    (add-to-list 'linum-disabled-modes-list "org-mode"))

#+END_SRC

** Keywords

My todo system is fairly simple. =TODO= = unsorted, =ONDECK= = could be done at anytime, =WAITING= = waiting on something out of my control, =SOMEDAY= = not urgent, =CURRENT= = the thing I am currently working on. I've given these keywords colors from Dracula theme.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
    '((sequence "TODO(t)" "ONDECK(o)" "WAITING(w)" "SOMEDAY(s)" "CURRENT(c)" "|" "DONE(d)")))

   ;; For Dracula Theme
   (setq org-todo-keyword-faces
     '(("ONDECK" . (:foreground "#f1fa8c" :weight bold))   
       ("WAITING" . (:foreground "#bd93f9" :weight bold)) 
       ("CANCELED" . (:foreground "#ff5555" :weight bold))
       ("CURRENT" . (:foreground "#50fa7b" :weight bold))
       ("SOMEDAY" . (:foreground "#6272a4" :weight bold))))

#+END_SRC

** Visual Styling

   I prefer to use fancy bullets, rather than a row of *s. Though every now and then I like to go back to a simpler style with one font size and regular bullets.

#+BEGIN_SRC emacs-lisp
  (setq org-hide-leading-stars t)
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

   Dracula Theme has recently revamped their =Org-mode= colors so I have switched to their defaults. I use a single character ellipsis, though sometimes switch to an arrow or other /fancy/ symbol.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " …")
#+END_SRC

   I like some whitespace between my headings.

#+BEGIN_SRC emacs-lisp
  (setq org-cycle-separator-lines 0)
#+END_SRC

   I prefer my text to wrap.

#+BEGIN_SRC emacs-lisp 
  (setq org-startup-truncated nil)
#+END_SRC

** Org Capture

   =Org= allows for capturing, which allows you to create/edit Org files whereever you are in Emacs. I have three kinds of Org Captures:
- TODO: adds a todo item to my Inbox heading in my main todo.txt file
- New Note: creates a new note file and saves it to my notes folder
- Kill Ring Note: creates a new note with whatever is currently at the head of my kill ring to a new note. I am considering changing this to add to an ongoing file instead.

#+BEGIN_SRC emacs-lisp
  (defun capture-report-date-file (path)
    (let ((name (read-string "Name: ")))
      (expand-file-name (format "%s.txt" name) path)))

  (setq org-capture-templates
    '(
      ("t" "TODO" entry (file+headline "~/Dropbox/Notes/todo.txt" "Inbox")
       "** TODO %^{prompt}\n%U\n")
      ("n" "New Note" entry (file (capture-report-date-file "~/Dropbox/Notes/"))
       "** %^{prompt}\n %a\n%U\n")
      ("k" "Kill Ring Note" entry (file (capture-report-date-file "~/Dropbox/Notes"))
       "** %c\n %? %a\n %U\n")))
#+END_SRC

** Org-babel

   Org-babel is a system that allows for source code blocks within an Org mode document. It is very nice for notes, or for literate progamming, like this config file.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-src-window-setup 'current-window)
  (setq org-confirm-babel-evaluate nil)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC

* Programming Stuff

This section is for stuff that helps with programming and coding. (note to self, look into diff-hl)

** General Stuff

I like yasnippet for snippets, but I generally rely on auto-complete to speed up my coding.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :defer t
    :config
    (yas-reload-all)
    (setq yas-snippet-dirs '("~/.emacs.d/snippets"
                             "~/.emacs.d/remote-snippets"))
    (setq tab-always-indent 'complete)
    (setq yas-prompt-functions '(yas-completing-prompt
                                 yas-ido-prompt
                                 yas-dropdown-prompt))
  (define-key yas-minor-mode-map (kbd "<escape>") 'yas-exit-snippet))
  (ac-config-default)
#+END_SRC

I use relative line numbers, which helps with the Vim bindings. I use a 0 offset, so if I want to delete to a line and it says its line 4 I can press =d-4-k=.

#+BEGIN_SRC emacs-lisp
  (require 'linum-relative)

  (linum-mode)
  (global-linum-mode)
  (setq linum-format "%4d \u2502 ")
  (set-face-attribute 'linum nil :slant 'normal)
  (with-eval-after-load 'linum
  (linum-relative-toggle))
  (setq linum-relative-current-symbol "->")
  (setq linum-relative-plusp-offset 0)
#+END_SRC

I use smooth scrolling, it might be a placebo.

#+BEGIN_SRC emacs-lisp
  (use-package smooth-scrolling
    :config
    (smooth-scrolling-mode 1))
#+END_SRC

A few other useful packages for coding.

#+BEGIN_SRC emacs-lisp
  (use-package fill-column-indicator)
  (use-package unbound)
  (use-package nnir)
  (use-package dumb-jump
    :config
    (dumb-jump-mode))
#+END_SRC

** Emacs-lisp

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (rainbow-delimiters-mode)))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (setq python-indent-offset 2)
#+END_SRC

** Shell and bash scripting

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (rainbow-delimiters-mode)
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+END_SRC

** Ruby

#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-mode-hook
    (lambda ()
      (setq ruby-insert-encoding-magic-comment nil)
        (yas-minor-mode)
        (robe-mode)
        (rainbow-delimiters-mode)
        (local-set-key "\r" 'newline-and-indent)
        (flymake-mode)
        (flymake-ruby-load)
        (define-key ruby-mode-map (kbd "C-c C-c") 'xmp)
        (define-key ruby-mode-map (kbd "C-c C-s") 'inf-ruby)
        (define-key ruby-mode-map (kbd "C-c C-r") 'ruby-send-region)
        (define-key ruby-mode-map (kbd "C-c C-z") 'ruby-switch-to-inf)
        (define-key ruby-mode-map (kbd "C-c C-l") 'ruby-load-file)
        (define-key ruby-mode-map (kbd "C-c C-b") 'ruby-send-block)
  ))
  (add-to-list 'auto-mode-alist
    '("\\.\\(?:erb\\)\\'" . web-mode))

  (add-to-list 'auto-mode-alist
    '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))
  (add-to-list 'auto-mode-alist
    '("\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))

#+END_SRC

** web-mode

=Web-mode= is an Emacs major mode that gives syntax highlighting for web source files with multiple languages like html with php or .erb files.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :defer t
    :config
    (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb$" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.twig$" . web-mode))
    (setq web-mode-attr-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-indent-style 2)
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-sql-indent-offset 2))
#+END_SRC

* Powerline

[[https://github.com/milkypostman/powerline][Powerline]] is a mode line replacement for Emacs, based on Vim powerline. I've spent far too much time tweaking my Powerline and it shows no sign of stopping.

You customize the look of your powerline by defining faces for when the powerline is on the active buffer, or it's inactive. I've taken my colors from Dracula Theme, so it matches the rest of my config. Emacs in the terminal is limited to 256 colors, almost all of them bright, so darker colors don't look good when using the terminal. =(display-graphic-p)= lets me check if I'm on a terminal or not and set colors that look better if so.

#+BEGIN_SRC emacs-lisp

  (setq display-time-format "%I:%M")
  (setq display-time-mail-directory "~/.Maildir/Personal/INBOX/new")
  (setq display-time-default-load-average nil)
  (display-time-mode 1)

    (defgroup segments-group nil "My powerline line segments" :group 'segments)

  (if (display-graphic-p)
    (defface my-pl-segment1-active
      '((t (:foreground "#f1fa8c" :background "#3a2e58")))
      "Powerline first segment active face.")
    (defface my-pl-segment1-active
      '((t (:foreground "#f1fa8c" :background "#5f00af")))
      "Powerline first segment active face."))

    (defface my-pl-segment1-inactive
     '((t (:foreground "#f8f8f2" :background "#545565")))
      "Powerline first segment inactive face.")
    (defface my-pl-segment2-active
      '((t (:foreground "#f8f8f2" :background "#bd93f9")))
      "Powerline second segment active face.")
    (defface my-pl-segment2-inactive
      '((t (:foreground "#f8f8f2" :background "#545565")))
      "Powerline second segment inactive face.")

  (if (display-graphic-p)
    (defface my-pl-segment3-active
      '((t (:foreground "#bd93f9" :background "#3a2e58")))
      "Powerline third segment active face.")
    (defface my-pl-segment3-active
      '((t (:foreground "#bd93f9" :background "#5f00af")))
      "Powerline third segment active face."))

    (defface my-pl-segment3-inactive
      '((t (:foreground "#f8f8f2" :background "#545565")))
      "Powerline third segment inactive face.")
    (defface my-pl-segment4-active
      '((t (:foreground "#ffffff" :background "#ff79c6")))
      "Powerline hud segment active face.")
    (defface my-pl-segment4-inactive
      '((t (:foreground "#ffffff" :background "#f8f8f2")))
      "Powerline hud segment inactive face.")


  (if (display-graphic-p)
    (defface my-pl-segment5-active
      '((t (:foreground "#ff79c6" :background "#3a2e58")))
      "Powerline buffersize segment active face.")
    (defface my-pl-segment5-active
      '((t (:foreground "#ff79c6" :background "#5f00af")))
      "Powerline buffersize segment active face."))

    (defface my-pl-segment5-inactive
      '((t (:foreground "#f8f8f2" :background "#545565")))
      "Powerline buffersize segment inactive face.")

  (if (display-graphic-p)
    (defface my-pl-segment6-active
     '((t (:foreground "#f1fa8c" :background "#3a2e58" :weight bold)))
      "Powerline buffer-id  segment active face.")
    (defface my-pl-segment6-active
     '((t (:foreground "#f1fa8c" :background "#5f00af" :weight bold)))
      "Powerline buffer-id  segment active face."))
    
    (defface my-pl-segment6-inactive
     '((t (:foreground "#f8f8f2" :background "#545565" :weight bold)))
      "Powerline buffer-id  segment inactive face.")
#+END_SRC


Then I use them to define a theme in a function. It looks a little confusing at first but it becomes easy with a little experimentation. The powerline is broken into two halves, the left (lhs) and right (rhs) with a section in the middle that fills any empty space.

#+BEGIN_SRC emacs-lisp
    (defun andy--powerline-default-theme ()
      "Set up my custom Powerline with Evil indicators."
      (interactive)
      (setq-default mode-line-format
        '("%e"
          (:eval
           (let* ((active (powerline-selected-window-active))
             (seg1 (if active 'my-pl-segment1-active 'my-pl-segment1-inactive))
             (seg2 (if active 'my-pl-segment2-active 'my-pl-segment2-inactive))
             (seg3 (if active 'my-pl-segment3-active 'my-pl-segment3-inactive))
             (seg4 (if active 'my-pl-segment4-active 'my-pl-segment4-inactive))
             (seg5 (if active 'my-pl-segment5-active 'my-pl-segment5-inactive))
             (seg6 (if active 'my-pl-segment6-active 'my-pl-segment6-inactive))
             (separator-left (intern (format "powerline-%s-%s"
                                   (powerline-current-separator)
                                   (car powerline-default-separator-dir))))
             (separator-right (intern (format "powerline-%s-%s"
                                    (powerline-current-separator)
                                    (cdr powerline-default-separator-dir))))
                  (lhs (list (let ((evil-face (powerline-evil-face)))
                               (if evil-mode
                                   (powerline-raw (powerline-evil-tag) evil-face)
                                 ))
                             (if evil-mode
                                 (funcall separator-left (powerline-evil-face) seg1))
                             (powerline-raw "[%*]" seg1 'l)
                             (when powerline-display-buffer-size
                               (powerline-buffer-size seg5 'l))
                             (powerline-buffer-id seg6 'l)
                             (when (and (boundp 'which-func-mode) which-func-mode)
                               (powerline-raw which-func-format seg1 'l))
                             (powerline-raw " " seg1)
                             (funcall separator-left seg1 seg2)
                             (when (boundp 'erc-modified-channels-object)
                               (powerline-raw erc-modified-channels-object seg2 'l))
                             (powerline-major-mode seg2 'l)
                             (powerline-process seg2)
                             (powerline-narrow seg2 'l)
                             (powerline-raw " " seg2)
                             (funcall separator-left seg2 seg3)
                             (powerline-minor-modes seg3 'l)
                             ))
                             (rhs (list 
                             (funcall separator-right seg3 seg2)
                             (powerline-vc seg2 'r)
                             (powerline-raw "|" seg2 'r)
                             (unless window-system
                               (powerline-raw (char-to-string #xe0a1) seg2 'l))
                             (powerline-raw "%l" seg2 'l)
                             (powerline-raw ":" seg2 'r)
                             (powerline-raw "%c" seg2 'r)
                             (funcall separator-right seg2 seg1)
                             (powerline-raw " " seg1)
                             (powerline-raw global-mode-string seg3 'r)
                             (funcall separator-right seg1 seg2)
                             (powerline-raw "%6p" seg2 'r)
                             (when powerline-display-hud
                               (powerline-hud seg4 seg1)))))
             (concat (powerline-render lhs)
                     (powerline-fill seg3 (powerline-width rhs))
                     (powerline-render rhs)))))))

    (use-package powerline
      :ensure t
      :config
      (setq powerline-height 26)
      (setq powerline-default-separator (if (display-graphic-p) 'arrow-fade
                                          nil))
      (andy--powerline-default-theme))

#+END_SRC

I use =powerline-evil= to put a color changing evil state face on my powerline. If you are using Dracula theme, they will be Dracula colors. That change was my first accepted pull request to an open source project!

#+BEGIN_SRC emacs-lisp
  (use-package powerline-evil
    :ensure t)
#+END_SRC

* Projectile

=projectile= is a helpful way to search through files in a project.

#+BEGIN_SRC emacs-lisp
  (use-package projectile)
  (use-package helm-projectile)
#+END_SRC

I use a few basic settings and have =projectile= auto load whenever I'm in =ruby-mode=.

#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-mode-hook 'projectile-mode)
  (setq projectile-indexing-method 'alien)
  (setq projectile-switch-project-action 'projectile-find-file)
  (setq projectile-completion-system 'default)
  (setq projectile-enable-caching nil)

  (helm-projectile-on)

  (set-face-attribute 'helm-source-header nil :foreground "#ffb86c" :height 1.66)
#+END_SRC 

* mu4e

=mu4e= is an email client that works within Emacs. I use =mu4e-multi= to manage my work and personal accounts and =evil-mu4e= for some keybinding changes.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e)
  (require 'mu4e-multi)
  (use-package evil-mu4e)
#+END_SRC

General Configuragtion

#+BEGIN_SRC emacs-lisp
    (setq mu4e-mu-binary "/usr/local/Cellar/mu/HEAD/bin/mu")
    (setq mu4e-maildir "/Users/Andy/.Maildir")

    (setq mu4e-multi-account-alist
      '(("personal"
         (user-mail-address .  "andy@andypierz.com")
         (user-full-name  .   "Andy Pierz")
         (mu4e-sent-folder .  "/personal/Sent\ Items")
         (mu4e-drafts-folder . "/personal/Drafts")
         (mu4e-trash-folder .  "/personal/Trash")
         (mu4e-refile-folder . "/personal/Archive"))
        ("work"
         (user-mail-address .  "andy@mutdut.com")
         (user-fullname . "Andy Pierz")
         (mu4e-sent-folder .  "/work/Sent\ Items")
         (mu4e-drafts-folder . "/work/Drafts")
         (mu4e-trash-folder .  "/work/Trash")
         (mu4e-refile-folder . "/work/Archive"))))

    (mu4e-multi-enable)

    (setq mu4e-drafts-folder "/drafts")


    ;;set attachment downloads directory
    (setq mu4e-attachment-dir  "~/Downloads")

    ;; setup some handy shortcuts
    ;; you can quickly switch to your Inbox -- press ``ji''
    ;; then, when you want archive some messages, move them to
    ;; the 'All Mail' folder by pressing ``ma''.

    (setq mu4e-maildir-shortcuts
      '( ("/personal/INBOX"              . ?i)
         ("/personal/Sent\ Items"   . ?s)
         ("/personal/Trash"       . ?t)
         ("/personal/Archive"    . ?a)
         ("/personal/Starred"    . ?p)
         ("/personal/Drafts"    . ?d)
           
         ("/work/INBOX"      . ?w)
         ("/work/Drafts"      . ?z)
         ("/work/Sent\ Items"       . ?f)
         ("/work/Archive"    . ?o)))


    ;; allow for updating mail using 'U' in the main view:
    (setq mu4e-get-mail-command "offlineimap")
    (setq mu4e-update-interval 300)

    ;; something about ourselves
    (setq
      user-mail-address "andy@andypierz.com"
      user-full-name  "Andy Pierz"
      mu4e-compose-signature
      (concat
        ""
        ""))


    (require 'smtpmail)

    (setq message-send-mail-function 'smtpmail-send-it
      smtpmail-stream-type 'ssl
      smtpmail-default-smtp-server "mail.hover.com"
      smtpmail-smtp-server "mail.hover.com"
      smtpmail-smtp-service 465)

    ;; don't keep message buffers around
    (setq message-kill-buffer-on-exit t)

    (defvar my-mu4e-account-alist
      '(("personal"
      ;; about me
      (user-mail-address      "andy@andypierz.com")
      (user-full-name         "Andy Pierz")
      ;; smtp
      (smtpmail-stream-type ssl)
      (smtpmail-starttls-credentials '(("mail.hover.com" 587 nil nil)))
      (smtpmail-default-smtp-server "mail.hover.com")
      (smtpmail-smtp-server "mail.hover.com")
      (smtpmail-smtp-service 465))
      ("work"
      ;; about me
      (user-mail-address      "andy@mutdut.com")
      (user-full-name         "Andy Pierz")
      ;;(mu4e-compose-signature "0xAX")

      ;; smtp
      (smtpmail-stream-type ssl)
      (smtpmail-auth-credentials '(("mail.hover.com" 25 "andy@mutdut.com" nil)))
      (smtpmail-default-smtp-server "mail.hover.com")
      (smtpmail-smtp-service 465))))

    (defun my-mu4e-set-account ()
      "Set the account for composing a message."
      (let* ((account
        (if mu4e-compose-parent-message
          (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
          (string-match "/\\(.*?\\)/" maildir)
          (match-string 1 maildir))
          (completing-read (format "Compose with account: (%s) "
            (mapconcat #'(lambda (var) (car var)) my-mu4e-account-alist "/"))
            (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
              nil t nil nil (car my-mu4e-account-alist))))
            (account-vars (cdr (assoc account my-mu4e-account-alist))))
        (if account-vars
          (mapc #'(lambda (var)
           (set (car var) (cadr var)))
              account-vars)
        (error "No email account found"))))

    (add-hook 'mu4e-compose-pre-hook 'my-mu4e-set-account)


    (use-package evil-mu4e)

    (define-key mu4e-headers-mode-map "p" 'mu4e-headers-mark-for-flag)

    (add-hook 'mu4e-main-mode-hook 'evil-motion-state)
    (add-hook 'mu4e-headers-mode-hook 'evil-motion-state)
#+END_SRC


Use Dired to add attachments to emails.

#+BEGIN_SRC emacs-lisp
    (require 'gnus-dired)
    ;; make the `gnus-dired-mail-buffers' function also work on
    ;; message-mode derived modes, such as mu4e-compose-mode
    (defun gnus-dired-mail-buffers ()
      "Return a list of active message buffers."
      (let (buffers)
        (save-current-buffer
          (dolist (buffer (buffer-list t))
      (set-buffer buffer)
      (when (and (derived-mode-p 'message-mode)
        (null message-sent-message-via))
        (push (buffer-name buffer) buffers))))
        (nreverse buffers)))

    (setq gnus-dired-mail-mode 'mu4e-user-agent)
    (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
#+END_SRC

Show some images in email messages.

#+BEGIN_SRC emacs-lisp

    (setq mu4e-view-show-images t)
    (setq mu4e-view-show-image-max-width 800)
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))
    (setq mu4e-view-prefer-html nil)

#+END_SRC


Convert html emails to text.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-html2text-command 'mu4e-shr2text)
#+END_SRC
* Magit

Magit is Emacs' Git interface.

#+BEGIN_SRC emacs-lisp
  (use-package magit)
  (use-package evil-magit)


#+END_SRC

This is to encrypt my password so I can use it when sending email. If anyone knows how to set this up so it doesn't trigger an error everytime I re eval my buffer please let me know:

#+BEGIN_SRC emacs-lisp
  (use-package epa-file
    :config
    (unless (memq epa-file-handler file-name-handler-alist)
    (epa-file-enable)))
#+END_SRC
