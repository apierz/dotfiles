#+Title: config.org

#+OPTIONS: TOC:nil
#+STARTUP: overview

* Emacs Configuration

This is my personal Emacs configuration. I use the [[https://github.com/railwaycat/homebrew-emacsmacport][Railwaycat Emacs for Mac]] port. It has two main advantages over the Emacs for Mac OSX port for me: 1. it renders colors better, and 2. It lets me use 2 finger swiping to navigate through buffers, which is very handy when I am looking at Emacs while working on something else.

*** Screenshot of my config
[[https://github.com/apierz/dotfiles/blob/master/screenshot.png?raw=true]]

* Personal Information

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Andy Pierz"
        user-mail-address "andy@andypierz.com")
#+END_SRC
* Packages and Paths

The first thing that gets loaded is =package=, Emacs' package manager. I then add some common repositories for Emacs packages and initialize package.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" .
  "http://stable.melpa.org/packages/"))
  (add-to-list 'package-archives '("marmalade" . "https://marmalade-repo.org/packages/"))

  (setq package-enable-at-startup nil)
  (setq package-check-signature nil)
#+END_SRC

Next I want to set my load paths, it's mostly the standard folders, plus any other working directories.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "snippets" user-emacs-directory))
  (add-to-list 'load-path "~/.emacs.d/plugins")
  (add-to-list 'load-path "~/.emacs.d/plugins/evil-org-mode")
  (add-to-list 'load-path "~/.emacs.d/elpa/hoon-mode.el")
  (add-to-list 'load-path "~/Documents/Programming_Projects/nofrils-civic-theme.el")
  (add-to-list 'load-path "~/.emacs.d/elpa/colorless-themes.el")
  (add-to-list 'load-path "/usr/local/Cellar/mu/HEAD-1f232b6/bin/mu")
  (add-to-list 'exec-path "/usr/local/bin")

#+END_SRC

=use-package= is a =require= replacement that helps Emacs load faster. Might be a placebo.

#+BEGIN_SRC emacs-lisp
  (require 'use-package)
#+END_SRC

* Essential Settings

** Simple Configuration Settings

These are basic Emacs settings. They include inhibiting the startup screen and menu-bar and various small visual preferences.

#+BEGIN_SRC emacs-lisp
    (setq inhibit-splash-screen t
          inhibit-startup-message t
          inhibit-startup-echo-area-message t)
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (when (boundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
    (show-paren-mode nil)
    (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
    (setq-default left-fringe-width nil)
    (setq-default indent-tabs-mode nil)
    ;; (eval-after-load "vc" '(setq vc-handled-backends nil))
    ;; (setq vc-follow-symlinks t)
    (setq large-file-warning-threshold nil)
    (setq split-width-threshold nil)
    (setq custom-safe-themes t)
    (put 'narrow-to-region 'disabled nil)
    (setq global-visual-line-mode t)
    (setq word-wrap t)
    (setq initial-major-mode 'org-mode)
    (setq initial-scratch-message "")
    (setq-default fill-column 80)
    (setq-default tab-width 2)
    (put 'dired-find-alternate-file 'disabled nil)
    (when window-system
     (set-frame-position (selected-frame) 0 0)
     (set-frame-size (selected-frame) 100 100))


#+END_SRC

** Title Bar Configuration

Emacs@hostname is not very useful information for the title bar, so I have it display the current buffer file path instead.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
    '("" invocation-name ": "(:eval (if (buffer-file-name)
                  (abbreviate-file-name (buffer-file-name))
                    "%b"))))
#+END_SRC


** Backup Configuration

I prefer for Emacs to store automatic backups in a central location, rather than leaving them strewn about.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/Documents/emacs_backups"))
        backup-by-copying      t  ; Don't de-link hard links
        version-control        t  ; Use version numbers on backups
        delete-old-versions    t  ; Automatically delete excess backups:
        kept-new-versions      5  ; how many of the newest versions to keep
        kept-old-versions      5) ; and how many of the old

#+END_SRC

* Utility Functions

Small utility functions, mostly collected from others.


** From [[https://github.com/aaronbieber][aaronbieber]]

#+BEGIN_SRC emacs-lisp
    (defun cycle-powerline-separators (&optional reverse)
      "Set Powerline separators in turn.  If REVERSE is not nil, go backwards."
     (interactive)
     (let* ((fn (if reverse 'reverse 'identity))
       (separators (funcall fn '("arrow" "arrow-fade" "slant"
                                 "chamfer" "wave" "brace" "roundstub" "zigzag"
                                 "butt" "rounded" "contour" "curve")))
       (found nil))
      (while (not found)
        (progn (setq separators (append (cdr separators) (list (car separators))))
        (when (string= (car separators) powerline-default-separator)
          (progn (setq powerline-default-separator (cadr separators))
             (setq found t)
              (redraw-display)))))))


    (defun rename-this-file-and-buffer (new-name)
      "Renames both current buffer and file it's visiting to NEW-NAME."
      (interactive "sNew name: ")
      (let ((name (buffer-name))
            (filename (buffer-file-name)))
        (unless filename
          (error "Buffer '%s' is not visiting a file!" name))
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn
            (when (file-exists-p filename)
             (rename-file filename new-name 1))
            (rename-buffer new-name)
    (set-visited-file-name new-name)))))

    (defun delete-this-file ()
      "Delete the current file, and kill the buffer."
      (interactive)
      (or (buffer-file-name) (error "No file is currently being edited"))
      (when (yes-or-no-p (format "Really delete '%s'?"
                                 (file-name-nondirectory buffer-file-name)))
        (delete-file (buffer-file-name))
    (kill-this-buffer)))


    (require 'htmlfontify)
    (defun fontify-and-browse ()
      "Fontify the current buffer into HTML, write it to a temp file, and open it in a browser."
      (interactive)
      (let* ((fontified-buffer (hfy-fontify-buffer))
             (temp-file-name (make-temp-file "ff" nil ".html")))
        (with-current-buffer fontified-buffer
          (write-region (point-min) (point-max) temp-file-name))
        (browse-url (concat "file://" temp-file-name))))


    (defun show-first-occurrence ()
      "Display the location of the word at point's first occurrence in the buffer."
      (interactive)
      (save-excursion
        (let ((search-word (thing-at-point 'symbol t)))
          (goto-char 1)
          (re-search-forward search-word)
          (message (concat
                    "L" (number-to-string (line-number-at-pos)) ": "
                    (replace-regexp-in-string
                     "[ \t\n]*\\'"
                     ""
                     (thing-at-point 'line t)
                     ))))))

    (defun switch-to-previous-buffer ()
      "Switch to previously open buffer.
    Repeated invocations toggle between the two most recently open buffers."
      (interactive)
      (switch-to-buffer (other-buffer (current-buffer) 1)))

    (defun narrow-and-set-normal ()
      "Narrow to the region and, if in a visual mode, set normal mode."
      (interactive)
      (narrow-to-region (region-beginning) (region-end))
      (if (string= evil-state "visual")
          (progn (evil-normal-state nil)
    (evil-goto-first-line))))

#+END_SRC

** From [[http://www.github.com/hrs][hrs]]

#+BEGIN_SRC emacs-lisp
  (defmacro diminish-minor-mode (filename mode &optional abbrev)
    "Supply a FILENAME, to hide a minor MODE or replace with an ABBREV."
    `(eval-after-load (symbol-name ,filename)
       '(diminish ,mode ,abbrev)))

  (defmacro diminish-major-mode (mode-hook abbrev)
    "Supply a MODE-HOOK, to hide a major MODE or replace with an ABBREV."
    `(add-hook ,mode-hook
               (lambda () (setq mode-name ,abbrev))))
#+END_SRC

** Mine + Unknown

#+BEGIN_SRC emacs-lisp

      (setq andy/themes '(nofrils-acme nofrils-civic leuven dracula))
      (setq andy/themes-index 0)

      (defun andy/cycle-theme ()
         (interactive)
         (setq andy/themes-index (% (1+ andy/themes-index) (length andy/themes)))
         (andy/load-indexed-theme))

       (defun andy/load-indexed-theme ()
       (andy/try-load-theme (nth andy/themes-index andy/themes)))

       (defun andy/try-load-theme (theme)
          (if (ignore-errors (load-theme theme :no-confirm))
               (mapcar #'disable-theme (remove theme custom-enabled-themes))
               (message "Unable to find theme file for ‘%s’" theme)))


      (defun search-my-notes (searchforthis)
        "Search for SEARCHFORTHIS."
        (interactive "sSearch Query: ")
        (rgrep searchforthis "*.txt"  "/Users/Andy/Dropbox/Notes"))

      (eval-after-load "grep"
        '(grep-compute-defaults))

      (defun minibuffer-keyboard-quit ()
        "Abort recursive edit.
      In Delete Selection mode, if the mark is active, just deactivate it;
      then it takes a second \\[keyboard-quit] to abort the minibuffer."
        (interactive)
        (if (and delete-selection-mode transient-mark-mode mark-active)
            (setq deactivate-mark  t)
          (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
          (abort-recursive-edit)))

      (defun andy-new-empty-buffer ()
        "Open a new empty buffer."
        (interactive)
        (let ((ξbuf (generate-new-buffer "untitled")))
          (switch-to-buffer ξbuf)
          (funcall (and initial-major-mode))
          (setq buffer-offer-save t)))

  (defun region-to-hexcol ()
    (interactive)
    (let
        ((start (region-beginning))
         (end (region-end))
         (text))

      (setq text (buffer-substring-no-properties start end))

      (when (string-match "^[[:digit:]]+$" text)
        (setq text (format "%02x" (string-to-number text)))
        (delete-region start end)
        (insert text))))

  (defun rgb-to-hex ()
    (interactive)

    (let
        ((start (region-beginning))
         (end (region-end)))

      (goto-char start)
      (set-mark start)
      (skip-chars-forward "0-9")
      (region-to-hexcol)

      (skip-chars-forward ", ")
      (set-mark (point))
      (skip-chars-forward "0-9")
      (region-to-hexcol)

      (skip-chars-forward ", ")
      (set-mark (point))
      (skip-chars-forward "0-9")
      (region-to-hexcol)

      (setq end (point))
      (goto-char start)

      (save-restriction
        (narrow-to-region start end)
        (while (re-search-forward "[, ]" nil t) (replace-match "" nil t)))))


  ;; recursively find .org files in provided directory
  ;; modified from an Emacs Lisp Intro example
  (defun sa-find-org-file-recursively (&optional directory filext)
    "Return .org and .org_archive files recursively from DIRECTORY.
  If FILEXT is provided, return files with extension FILEXT instead."
    (interactive "DDirectory: ")
    (let* (org-file-list
           (case-fold-search t)         ; filesystems are case sensitive
           (file-name-regex "^[^.#].*") ; exclude dot, autosave, and backupfiles
           (filext (or filext "org$\\\|org_archive"))
           (fileregex (format "%s\\.\\(%s$\\)" file-name-regex filext))
           (cur-dir-list (directory-files directory t file-name-regex)))
      ;; loop over directory listing
      (dolist (file-or-dir cur-dir-list org-file-list) ; returns org-file-list
        (cond
         ((file-regular-p file-or-dir)             ; regular files
          (if (string-match fileregex file-or-dir) ; org files
              (add-to-list 'org-file-list file-or-dir)))
         ((file-directory-p file-or-dir)
          (dolist (org-file (sa-find-org-file-recursively file-or-dir filext)
                            org-file-list) ; add files found to result
            (add-to-list 'org-file-list org-file)))))))
#+END_SRC

* Visual Stuff


I used to use =nofrils-acme= for my color theme and SF Mono as my font, but I change both all the time.

#+BEGIN_SRC emacs-lisp

  (require 'nofrils-acme-theme)
  (load-theme 'nofrils-acme t)
  (andy/load-indexed-theme)

        (set-face-attribute 'default nil
                        :family "SF Mono" :height 120 :weight 'normal :width 'condensed)

        (mac-auto-operator-composition-mode)

#+END_SRC

Just to be double-dog sure it ends up as utf-8...

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq buffer-file-coding-system 'utf-8)
#+END_SRC

I use some diminsh functions I got from [[https://github.com/hrs][hrs]]. This lets me hide some minor modes and rename others as encircled unicode characters. I also rename some major modes to save a little space in my powerline.

#+BEGIN_SRC emacs-lisp
  (diminish-minor-mode 'auto-complete 'auto-complete-mode " ⓐ ")
  (diminish-minor-mode 'flycheck 'flycheck-mode " ⓕ ")
  (diminish-minor-mode 'projectile 'projectile-mode " ⓟ ")
  (diminish-minor-mode 'robe 'robe-mode " ⓡ ")
  (diminish-minor-mode 'flymake 'flymake-mode " ⓜ ")
  (diminish-minor-mode 'server 'server-mode)
  (diminish-minor-mode 'evil-snipe 'evil-snipe-local-mode)
  (diminish-minor-mode 'evil-surround 'evil-surround-mode )
  (diminish-minor-mode 'evil-commentary 'evil-commentary-mode)
  (diminish-minor-mode 'yasnippet 'yas-minor-mode)
  (diminish-minor-mode 'autorevert 'auto-revert-mode)
  (diminish-minor-mode 'flyspell 'flyspell-mode)
  (diminish-minor-mode 'undo-tree 'undo-tree-mode)
  (diminish-minor-mode 'evil-org 'evil-org-mode)
  (diminish-minor-mode 'git-gutter 'git-gutter-mode)
  (diminish-minor-mode 'company 'company-mode)
  (diminish-minor-mode 'doom-buffer 'doom-buffer-mode)
  (diminish-minor-mode 'rainbow 'rainbow-mode)

  (diminish-major-mode 'emacs-lisp-mode-hook ".el")
  (diminish-major-mode 'haskell-mode-hook "?=")
  (diminish-major-mode 'lisp-interaction-mode-hook "?")
  (diminish-major-mode 'python-mode-hook ".py")
  (diminish-major-mode 'ruby-mode-hook ".rb")
  (diminish-major-mode 'sh-mode-hook ".sh")
  (diminish-major-mode 'markdown-mode-hook ".md")

#+END_SRC

* evil-mode

I prefer the Vim keybindings and use them wherever possible in Emacs. I recently made a switch to HJKL from IJKL when I learned the arrow keys on my =Pok3r= keyboard could be reprogrammed to use HJKL everywhere so I'm currently tring to unlearn my old bad habits.

** Main package:

#+BEGIN_SRC emacs-lisp
  (use-package evil)
  (evil-mode t)
#+END_SRC

** Addons, based on Vim plugins

   =evil-surround= is based on tpope's plugin and makes it easy to change surrounding syntax like ", ', (, {, etc. =evil-commentary= is also based on a tpope plugin that makes it easy to comment a line or lines. [g-c-c] will comment a line [g-c-4-j] will comment the next 4 lines, etc. =evil-snipe= is an interesting package that lets you find by two characters instead of one to better target specific cursor jumps.

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader)
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
  (use-package evil-commentary
    :config
    (evil-commentary-mode))
  (use-package evil-snipe
    :config
    (evil-snipe-mode 1)
    (evil-snipe-override-mode 1))
  (use-package evil-numbers
  :config
  (define-key evil-normal-state-map (kbd "C-c +") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-c -") 'evil-numbers/dec-at-pt))

#+END_SRC

** Controls

   I make a few changes to the =dired= control map to make it more natural when using Vim style navigation. Also I use 'jk' as a quick shortcut to return to =evil-normal-state=.

#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :config
    (key-chord-mode 1))

  (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
  (key-chord-define evil-insert-state-map ",," "<")
  (key-chord-define evil-insert-state-map ".." ">")
  (key-chord-define evil-insert-state-map "[[" "[ ]")
  (key-chord-define evil-replace-state-map "jk" 'evil-normal-state)
  (key-chord-define evil-visual-state-map "jk" 'evil-normal-state)
  (key-chord-define evil-motion-state-map "jk" 'evil-normal-state)

  (key-chord-define-global "jk" 'evil-normal-state)

  (evil-define-key 'normal dired-mode-map "h" 'dired-up-directory)
  (evil-define-key 'normal dired-mode-map "l" 'dired-find-alternate-file)
  (evil-define-key 'normal dired-mode-map "v" 'dired-toggle-marks)
  (evil-define-key 'normal dired-mode-map "m" 'dired-mark)
  (evil-define-key 'normal dired-mode-map "u" 'dired-unmark)
  (evil-define-key 'normal dired-mode-map "U" 'dired-unmark-all-marks)
  (evil-define-key 'normal dired-mode-map "c" 'dired-create-directory)
  (evil-define-key 'normal dired-mode-map "n" 'evil-search-next)
  (evil-define-key 'normal dired-mode-map "N" 'evil-search-previous)
  (evil-define-key 'normal dired-mode-map "q" 'kill-this-buffer)
  (setq evil-shift-width 2)

#+END_SRC

   I made some changes to the normal =evil-org= keybindings because I think these bindings are more intuitive.

#+BEGIN_SRC emacs-lisp
  (use-package evil-org)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-k") 'org-metaup)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-h") 'org-metaleft)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-j") 'org-metadown)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-l") 'org-metaright)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-K") 'org-shiftmetaup)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-H") 'org-shiftmetaleft)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-J") 'org-shiftmetadown)
  (evil-define-key 'normal evil-org-mode-map (kbd "M-L") 'org-shiftmetaright)
  (evil-define-key 'normal evil-org-mode-map (kbd "K") 'org-shiftup)
  (evil-define-key 'normal evil-org-mode-map (kbd "H") 'org-shiftleft)
  (evil-define-key 'normal evil-org-mode-map (kbd "J") 'org-shiftdown)
  (evil-define-key 'normal evil-org-mode-map (kbd "L") 'org-shiftright)
#+END_SRC

** Evil Leader

   =Evil Leader= is a package that let's you do quick shortcuts in =evil-mode=. While in =evil-normal-state= you press and hold your leader key ( for me its ,) and then press another key to trigger a function. It's very handy and great for triggering little utility functions you come accross or common vi commands.

#+BEGIN_SRC emacs-lisp
  (defun andy--config-evil-leader ()
    "Configure evil leader mode."
    (evil-leader/set-leader ",")
    (setq evil-leader/in-all-states 1)
    (evil-leader/set-key
      "k"  'switch-to-previous-buffer
      "m"  'previous-buffer
      "."  'next-buffer
      ":"  'eval-expression
      "d"  'delete-window
      "e"  'find-file
      "h"  'split-window-vertically
      "I"  'org-clock-in
      "O"  'org-clock-out
      "D"  'org-clock-display
      "R"  'org-clock-report
      "p"  'cycle-powerline-separators
      "b"  'helm-bookmarks
      "f"  'helm-mini
      "l"  'whitespace-mode       ;; Show invisible characters
      "nn" 'narrow-and-set-normal ;; Narrow to region and enter normal mode
      "nw" 'widen
      "1"  'delete-other-windows  ;; C-w o
      "r"  'rainbow-mode ;; show hexcodes in their actual color
      "S"  'delete-trailing-whitespace
      "t"  'gtags-reindex
      "T"  'gtags-find-tag
      "v"  'split-window-horizontally
      "w"  'save-buffer
      "x"  'helm-M-x))

  (global-evil-leader-mode)
  (andy--config-evil-leader)


#+END_SRC

** macOS Specific Stuff

   Use the standard OSX keys for copy/paste.

#+BEGIN_SRC emacs-lisp
  (defun pbcopy ()
    "Use OSX' pasteboard for copying."
    (interactive)
    (call-process-region (point) (mark) "pbcopy")
    (setq deactivate-mark t))

  (defun pbpaste ()
    "Use OSX' pasteboard for pasting."
    (interactive)
    (call-process-region (point) (if mark-active (mark) (point)) "pbpaste" t t))

  (defun pbcut ()
    "Use OSX' pasteboard for cutting."
    (interactive)
    (pbcopy)
    (delete-region (region-beginning) (region-end)))

  (global-set-key (kbd "M-c") 'pbcopy)
  (global-set-key (kbd "C-c x") 'pbcut)
  (global-set-key (kbd "M-v") 'pbpaste)


#+END_SRC

   Switch the macOS =Command= button to be Emacs =Meta= key.

#+BEGIN_SRC emacs-lisp

  (defun mac-switch-meta nil
    "Switch meta between Option and Command."
    (interactive)
    (if (eq mac-option-modifier nil)
        (progn
    (setq mac-option-modifier 'meta)
    (setq mac-command-modifier 'hyper)
  )
      (progn
        (setq mac-option-modifier nil)
        (setq mac-command-modifier 'meta))))

#+END_SRC


** Minor evil Configurations

   Stop that terrible cursor move back nonsense!

#+BEGIN_SRC emacs-lisp

(setq evil-move-cursor-back nil)

#+END_SRC

   Set some shortcuts to the function buttons.

#+BEGIN_SRC emacs-lisp
  (global-set-key [f1] 'mu4e)
  (global-set-key [f2] 'andy-new-empty-buffer)

  (global-set-key [f4] 'fci-mode)
  (global-set-key [f5] 'search-my-notes)
  (global-set-key [f6] 'display-line-numbers-mode)
  (global-set-key [f7] 'andy/cycle-theme)

  (use-package neotree)
  (global-set-key [f8] 'neotree-toggle)
#+END_SRC

   Robe Mode Commands

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-j") 'robe-jump)
#+END_SRC

   Magit Commands

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)

#+END_SRC

   Use ESC to quit non-evil stuff

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-motion-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key evil-emacs-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape]'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+END_SRC

   Use =evil= controls in =Dired= and other =motion-state= modes.

#+BEGIN_SRC emacs-lisp
  (setq evil-normal-state-modes (append evil-motion-state-modes
    evil-normal-state-modes))
#+END_SRC

Neotree needs a little tweaking to work well with =evil=.

#+BEGIN_SRC emacs-lisp
  (add-hook 'neotree-mode-hook
             (lambda ()
               (define-key evil-normal-state-local-map (kbd "h") 'neotree-enter-horizontal-split)
               (define-key evil-normal-state-local-map (kbd "v") 'neotree-enter-vertical-split)
               (define-key evil-normal-state-local-map (kbd "TAB") 'neotree-enter)
               (define-key evil-normal-state-local-map (kbd "SPC") 'neotree-enter)
               (define-key evil-normal-state-local-map (kbd "q") 'neotree-hide)
               (define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter)))
#+END_SRC

Change the color of the cursor to indicate what evil state I am in.
#+BEGIN_SRC emacs-lisp
  (setq evil-default-cursor (face-attribute 'cursor :background nil t)
        evil-normal-state-cursor 'box
        evil-emacs-state-cursor  `(,(face-attribute 'warning :foreground nil nil) box)
        evil-insert-state-cursor 'bar
        evil-visual-state-cursor 'hollow)
#+END_SRC

* Helm
Helm is useful for searching through Emacs and offers fuzzy searching. I prefer Helm for searching through my buffers, kill ring and other things. =helm-M-x= will also helpfully show any command shortcuts assigned to commands. 

#+BEGIN_SRC emacs-lisp
  (use-package helm)
  (use-package helm-config)
  (global-set-key (kbd "C-x b") 'helm-buffers-list)
  (global-set-key (kbd "C-x r b") 'helm-bookmarks)
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)

  (setq helm-split-window-in-side-p t)

  (with-eval-after-load
    'helm (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
       (define-key helm-map (kbd "ESC") 'helm-keyboard-quit)
  )
#+END_SRC

* Org-mode

=Org= is Emacs' famous markup language with all kinds of useful features. You can even write your Emacs config in =Org=, which is what I have done here.

#+BEGIN_SRC emacs-lisp
  (use-package org)
  (use-package ox)
  (use-package org-grep)
  (use-package org-capture)
#+END_SRC

These are the basic bindings =Org= recommends you use.

#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

I want everything in my notes folder to open in =Org-mode= and for .txt files to open in =Org-mode=. It is very rare I want to edit a plain text file without Org.

#+BEGIN_SRC emacs-lisp
  (setq org-export-coding-system 'utf-8)
  (setq org-agenda-files '("~/Dropbox/Notes"))
  (setq org-agenda-text-search-extra-files
      (append (sa-find-org-file-recursively "~/Dropbox/Notes" "txt")
              (sa-find-org-file-recursively "~/Dropbox/Notes" "org")))


  (add-hook 'find-file-hooks
    (lambda ()
      (let ((file (buffer-file-name)))
      (when (and file (equal (file-name-directory file) "~/Dropbox/Notes"))
      (org-mode)))))
#+END_SRC


#+BEGIN_SRC emacs-lisp

  (add-to-list 'org-latex-classes
               '("article"
                 "\\documentclass{article}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC

** Keywords

My todo system is fairly simple.
- =TODO= = could be done at anytime
- =WAITING= = waiting on something out of my control
- =NEEDED= = someone else is waiting on this
- =SOMEDAY= = not urgent
- =CURRENT= = working on now
- =CANCELLED= = no longer needs to be completed
- =DONE= = completed.

I've given these keywords colors from my current theme.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
    '((sequence "TODO(t)" "TOREAD(r)" "WAITING(w)" "CURRENT(c)" "SOMEDAY(s)" "NEEDED(n)" "|" "CANCELLED(a)" "DONE(d)")))

   ;; For Plan9 Theme
   (setq org-todo-keyword-faces
     '(("TODO"         . (:inherit org-todo :weight bold :slant normal :height 120 ))
       ("TOREAD"       . (:inherit org-todo :weight bold :slant normal :height 120 ))
       ("WAITING"      . (:inherit org-agenda-structure :weight bold :slant normal :height 120 ))
       ("CURRENT"      . (:inherit org-agenda-structure :weight bold :slant normal :height 120 ))
       ("DONE"         . (:inherit org-done :weight bold :slant normal :height 120 ))
       ("CANCELLED"    . (:inherit org-done :weight bold :slant normal :height 120 ))
       ("NEEDED"       . (:inherit org-todo :weight bold :slant normal :height 120 ))
       ("SOMEDAY"      . (:inherit org-document-info :weight bold :slant normal :height 120 ))))

#+END_SRC


** Visual Styling

   I prefer to use fancy bullets, rather than a row of *s. Though every now and then I like to go back to a simpler style with one font size and regular bullets.

#+BEGIN_SRC emacs-lisp
  ;; (setq org-hide-leading-stars t)
  ;; (use-package org-bullets
  ;;   :ensure t
  ;;   :config
  ;;   (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

Makes it so I can customize the appearance of checkbox text.
#+BEGIN_SRC emacs-lisp
  (defface org-checkbox-todo-text
      '((t (:inherit nil)))
      "Face for the text part of an unchecked org-mode checkbox.")

  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?: \\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-checkbox-todo-text prepend))
   'append)

  (defface org-checkbox-done-text
      '((t (:inherit 'shadow :bold nil)))
      "Face for the text part of a checked org-mode checkbox.")

  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-checkbox-done-text prepend))
   'append)

  ;; (custom-set-faces '(org-checkbox ((t (:foreground nil :strike-through nil)))))

#+END_SRC

  Acme theme has nice looking org defaults so I don't mess with them too much. There are a few things that help though)
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "…")
  (setq
        ;; org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t)
#+END_SRC

   I like some whitespace between my headings.

#+BEGIN_SRC emacs-lisp
  (setq org-cycle-separator-lines 2)
#+END_SRC

   I prefer my text to wrap.

#+BEGIN_SRC emacs-lisp
  (setq org-startup-truncated nil)
#+END_SRC

   Setting the date color:

#+BEGIN_SRC emacs-lisp
  (custom-set-faces '(org-date ((t (:foreground nil :background "#e8fce8" )))))

#+END_SRC


   Setting the tag color:

#+BEGIN_SRC emacs-lisp
  (custom-set-faces '(org-tag ((t (:foreground nil :background "#98ece8" :slant italic)))))

#+END_SRC

** Org Capture

   =Org= allows for capturing, which allows you to create/edit Org files whereever you are in Emacs. I have three kinds of Org Captures:
- TODO: adds a todo item to my Inbox heading in my main todo.txt file
- New Note: creates a new note file and saves it to my notes folder
- Kill Ring Note: creates a new note with whatever is currently at the head of my kill ring to a new note. I am considering changing this to add to an ongoing file instead.

#+BEGIN_SRC emacs-lisp
  (defun capture-report-date-file (path)
    (let ((name (read-string "Name: ")))
      (expand-file-name (format "%s.txt" name) path)))

  (setq org-capture-templates
    '(
      ("t" "TODO" entry (file+headline "~/Dropbox/Notes/todo.txt" "Inbox")
       "** TODO %^{prompt}\n%U\n")
      ("n" "New Note" entry (file (capture-report-date-file "~/Dropbox/Notes/"))
       "** %^{prompt}\n %a\n%U\n")
      ("k" "Kill Ring Note" entry (file (capture-report-date-file "~/Dropbox/Notes"))
       "** %c\n %? %a\n %U\n")))
#+END_SRC

** Org-babel

   Org-babel is a system that allows for source code blocks within an Org mode document. It is very nice for notes, or for literate progamming, like this config file.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-src-window-setup 'current-window)
  (setq org-confirm-babel-evaluate nil)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (ruby . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC


** Time Tracking

#+BEGIN_SRC emacs-lisp
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)

  (setq org-clocktable-defaults '(:scope file :maxlevel 8 :block today))
#+END_SRC

#+END_SRC
* Programming Stuff

This section is for stuff that helps with programming and coding. (note to self, look into diff-hl)

** General Stuff

I like yasnippet for snippets, but I generally rely on auto-complete to speed up my coding.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :defer t
    :config
    (yas-reload-all)
    (setq yas-snippet-dirs '("~/.emacs.d/snippets"
                             "~/.emacs.d/remote-snippets"))
    (setq tab-always-indent 'complete)
    (setq yas-prompt-functions '(yas-completing-prompt
                                 yas-ido-prompt
                                 yas-dropdown-prompt))
  (define-key yas-minor-mode-map (kbd "<escape>") 'yas-exit-snippet))

  (setq path-to-ctags "/usr/bin/ctags")
  (defun create-tags (dir-name)
      "Create tags file."
      (interactive "DDirectory: ")
      (shell-command
          (format "%s -f TAGS -e -R %s" path-to-ctags (directory-file-name dir-name)))
  )


  (require 'company)
  (add-hook 'after-init-hook 'global-company-mode)
  (require 'company-web-html)
  (add-to-list 'company-backends 'company-elisp)
  (add-to-list 'company-backends 'company-yasnippet)
  (add-to-list 'company-backends 'company-dabbrev)
  (add-to-list 'company-backends 'company-dabbrev-code)
#+END_SRC

I use relative line numbers, which helps with the Vim bindings. I use a 0 offset, so if I want to delete to a line and it says its line 4 I can press =d-4-j=.

#+BEGIN_SRC emacs-lisp

  (global-display-line-numbers-mode t)
  (setq display-line-numbers-type 'relative)
  (setq display-line-numbers "%4d \u2502 ")

  (set-face-attribute 'line-number-current-line nil :weight 'bold)
#+END_SRC

I use smooth scrolling, it might be a placebo.

#+BEGIN_SRC emacs-lisp
  (use-package smooth-scrolling
    :config
    (smooth-scrolling-mode 1))
#+END_SRC

A few other useful packages for coding.

#+BEGIN_SRC emacs-lisp
  (use-package fill-column-indicator)
  (use-package unbound)
  (use-package nnir)
#+END_SRC

** Emacs-lisp

#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'emacs-lisp-mode-hook
  ;;           (lambda ()
  ;;             (rainbow-delimiters-mode)))
#+END_SRC

** Hoon
#+begin_src emacs-lisp
  (load "hoon-mode")
 
  (add-hook 'hoon-mode
            (lambda ()
              (define-key hoon-mode-map (kbd "C-c r") 'hoon-eval-region-in-herb)
              (define-key hoon-mode-map (kbd "C-c b") 'hoon-eval-buffer-in-herb)))
#+end_src

** Shell and bash scripting

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+END_SRC

** Ruby

#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-mode-hook
    (lambda ()
      (setq ruby-insert-encoding-magic-comment nil)
        (yas-minor-mode)
        (robe-mode)
        (local-set-key "\r" 'newline-and-indent)
        (flymake-mode)
        (flymake-ruby-load)
        (define-key ruby-mode-map (kbd "C-c C-c") 'xmp)
        (define-key ruby-mode-map (kbd "C-c C-s") 'inf-ruby)
        (define-key ruby-mode-map (kbd "C-c C-r") 'ruby-send-region)
        (define-key ruby-mode-map (kbd "C-c C-z") 'ruby-switch-to-inf)
        (define-key ruby-mode-map (kbd "C-c C-l") 'ruby-load-file)
        (define-key ruby-mode-map (kbd "C-c C-b") 'ruby-send-block)
  ))
  (add-to-list 'auto-mode-alist
    '("\\.\\(?:erb\\)\\'" . web-mode))

  (add-to-list 'auto-mode-alist
    '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))
  (add-to-list 'auto-mode-alist
    '("\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))

#+END_SRC

** web-mode

=Web-mode= is an Emacs major mode that gives syntax highlighting for web source files with multiple languages like html with php or .erb files.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :defer t
    :config
    (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb$" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.twig$" . web-mode))
    (setq web-mode-attr-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-indent-style 2)
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-sql-indent-offset 2))
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'load-path "~/gocode/src/github.com/dougm/goflymake")
  ;; (require 'go-flymake)
#+END_SRC

* Projectile

=projectile= is a helpful way to search through files in a project.

#+BEGIN_SRC emacs-lisp
  (use-package projectile)
  (use-package helm-projectile)
#+END_SRC

I use a few basic settings and have =projectile= auto load whenever I'm in =ruby-mode=.

#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-mode-hook 'projectile-mode)
  (add-hook 'web-mode-hook 'projectile-mode)
  (setq projectile-indexing-method 'alien)
  (setq projectile-switch-project-action 'projectile-find-file)
  (setq projectile-completion-system 'default)
  (setq projectile-enable-caching nil)

  (helm-projectile-on)

  ;; (set-face-attribute 'helm-source-header nil :foreground "#ffb86c" :height 1.66)
#+END_SRC

* Magit

Magit is Emacs' Git interface.

#+BEGIN_SRC emacs-lisp
  (use-package magit)
  (use-package evil-magit)


#+END_SRC

This is to encrypt my password so I can use it when sending email. If anyone knows how to set this up so it doesn't trigger an error everytime I re eval my buffer please let me know:

#+BEGIN_SRC emacs-lisp
  (require 'epa-file)
  (epa-file-enable)
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (require 'doom-modeline)
  (doom-modeline-mode 1)

  ;; How tall the mode-line should be (only respected in GUI Emacs).
  (setq doom-modeline-height 25)

  ;; How wide the mode-line bar should be (only respected in GUI Emacs).
  (setq doom-modeline-bar-width 3)

  ;; Determines the style used by `doom-modeline-buffer-file-name'.
  ;;
  ;; Given ~/Projects/FOSS/emacs/lisp/comint.el
  ;;   truncate-upto-project => ~/P/F/emacs/lisp/comint.el
  ;;   truncate-from-project => ~/Projects/FOSS/emacs/l/comint.el
  ;;   truncate-with-project => emacs/l/comint.el
  ;;   truncate-except-project => ~/P/F/emacs/l/comint.el
  ;;   truncate-upto-root => ~/P/F/e/lisp/comint.el
  ;;   truncate-all => ~/P/F/e/l/comint.el
  ;;   relative-from-project => emacs/lisp/comint.el
  ;;   relative-to-project => lisp/comint.el
  ;;   file-name => comint.el
  ;;   buffer-name => comint.el<2> (uniquify buffer name)
  ;;
  ;; If you are expereicing the laggy issue, especially while editing remote files
  ;; with tramp, please try `file-name' style.
  ;; Please refer to https://github.com/bbatsov/projectile/issues/657.
  (setq doom-modeline-buffer-file-name-style 'truncate-upto-project)

  ;; Whether display icons in mode-line or not.
  (setq doom-modeline-icon t)

  ;; Whether display the icon for major mode. It respects `doom-modeline-icon'.
  (setq doom-modeline-major-mode-icon t)

  ;; Whether display color icons for `major-mode'. It respects
  ;; `doom-modeline-icon' and `all-the-icons-color-icons'.
  (setq doom-modeline-major-mode-color-icon t)

  ;; Whether display icons for buffer states. It respects `doom-modeline-icon'.
  (setq doom-modeline-buffer-state-icon t)

  ;; Whether display buffer modification icon. It respects `doom-modeline-icon'
  ;; and `doom-modeline-buffer-state-icon'.
  (setq doom-modeline-buffer-modification-icon t)

  ;; Whether display minor modes in mode-line or not.
  (setq doom-modeline-minor-modes nil)

  ;; If non-nil, a word count will be added to the selection-info modeline segment.
  (setq doom-modeline-enable-word-count nil)

  ;; If non-nil, only display one number for checker information if applicable.
  (setq doom-modeline-checker-simple-format t)


  (setq doom-modeline-vcs t)

  ;; The maximum displayed length of the branch name of version control.
  (setq doom-modeline-vcs-max-length 12)

  ;; Whether display perspective name or not. Non-nil to display in mode-line.
  (setq doom-modeline-persp-name t)

  ;; Whether display `lsp' state or not. Non-nil to display in mode-line.
  (setq doom-modeline-lsp t)

  ;; Whether display github notifications or not. Requires `ghub` package.
  (setq doom-modeline-github nil)

  ;; The interval of checking github.
  (setq doom-modeline-github-interval (* 30 60))

  ;; Whether display environment version or not
  (setq doom-modeline-env-version t)
  ;; Or for individual languages
  (setq doom-modeline-env-enable-python t)
  (setq doom-modeline-env-enable-ruby t)
  (setq doom-modeline-env-enable-perl t)
  (setq doom-modeline-env-enable-go t)
  (setq doom-modeline-env-enable-elixir t)
  (setq doom-modeline-env-enable-rust t)

  ;; Change the executables to use for the language version string
  (setq doom-modeline-env-python-executable "python")
  (setq doom-modeline-env-ruby-executable "ruby")
  (setq doom-modeline-env-perl-executable "perl")
  (setq doom-modeline-env-go-executable "go")
  (setq doom-modeline-env-elixir-executable "iex")
  (setq doom-modeline-env-rust-executable "rustc")

  ;; Whether display mu4e notifications or not. Requires `mu4e-alert' package.
  (setq doom-modeline-mu4e nil)

  ;; Whether display irc notifications or not. Requires `circe' package.
  (setq doom-modeline-irc nil)

  ;; Function to stylize the irc buffer names.
  ;; (setq doom-modeline-irc-stylize 'identity)

  ;;Visual Customization
   ;; (set-face-attribute 'doom-modeline-buffer-modified nil :background nil)
   (set-face-attribute 'doom-modeline-evil-insert-state nil :background nil)


#+END_SRC

* Version Control

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter)

  ;; If you enable global minor mode
  (global-git-gutter-mode +1)

  ;; If you would like to use git-gutter.el and linum-mode
  ;; (git-gutter:linum-setup)

  (global-set-key (kbd "C-x C-g") 'git-gutter)
  (global-set-key (kbd "C-x v =") 'git-gutter:popup-hunk)

  ;; Jump to next/previous hunk
  (global-set-key (kbd "C-x p") 'git-gutter:previous-hunk)
  (global-set-key (kbd "C-x n") 'git-gutter:next-hunk)

  ;; Stage current hunk
  (global-set-key (kbd "C-x v s") 'git-gutter:stage-hunk)
  ;; Revert current hunk

  (global-set-key (kbd "C-x v r") 'git-gutter:revert-hunk)

  ;; Mark current hunk
  (global-set-key (kbd "C-x v SPC") #'git-gutter:mark-hunk)

  (custom-set-variables
   '(git-gutter:modified-sign "▐") 
   '(git-gutter:added-sign "▐")    
   '(git-gutter:deleted-sign "▐"))
   '(git-gutter:update-interval 2)
   '(git-gutter:visual-line t)


  (custom-set-faces
   '(git-gutter:added    ((t (:foreground "#40883F"))))
   '(git-gutter:modified ((t (:foreground "#AF8700"))))
   '(git-gutter:deleted  ((t (:foreground "#FF5555")))))

#+END_SRC

